using System.Linq.Expressions;

public interface IGenericRepository<T> where T : class
{
    Task<T?> FirstOrDefaultAsync(Expression<Func<T, bool>>? filter = null, string includeProperties = "");
    Task<IEnumerable<T>> GetAllAsync(Expression<Func<T, bool>>? filter = null, string includeProperties = "");
    Task AddAsync(T entity);
    void Update(T entity);
    void Delete(T entity);
    Task SaveAsync();
}


using Microsoft.EntityFrameworkCore;
using System.Linq.Expressions;

public class GenericRepository<T> : IGenericRepository<T> where T : class
{
    private readonly DbContext _context;
    protected readonly DbSet<T> _dbSet;

    public GenericRepository(DbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }

    public async Task<T?> FirstOrDefaultAsync(Expression<Func<T, bool>>? filter = null, string includeProperties = "")
    {
        IQueryable<T> query = _dbSet;

        if (!string.IsNullOrWhiteSpace(includeProperties))
        {
            foreach (var includeProp in includeProperties.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries))
            {
                query = query.Include(includeProp.Trim());
            }
        }

        if (filter != null)
        {
            query = query.Where(filter);
        }

        return await query.FirstOrDefaultAsync();
    }

    public async Task<IEnumerable<T>> GetAllAsync(Expression<Func<T, bool>>? filter = null, string includeProperties = "")
    {
        IQueryable<T> query = _dbSet;

        if (!string.IsNullOrWhiteSpace(includeProperties))
        {
            foreach (var includeProp in includeProperties.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries))
            {
                query = query.Include(includeProp.Trim());
            }
        }

        if (filter != null)
        {
            query = query.Where(filter);
        }

        return await query.ToListAsync();
    }

    public async Task AddAsync(T entity)
    {
        await _dbSet.AddAsync(entity);
    }

    public void Update(T entity)
    {
        _dbSet.Attach(entity);
        _context.Entry(entity).State = EntityState.Modified;
    }

    public void Delete(T entity)
    {
        if (_context.Entry(entity).State == EntityState.Detached)
        {
            _dbSet.Attach(entity);
        }
        _dbSet.Remove(entity);
    }

    public async Task SaveAsync()
    {
        await _context.SaveChangesAsync();
    }
}

builder.Services.AddScoped(typeof(IGenericRepository<>), typeof(GenericRepository<>));

public class UserService
{
    private readonly IGenericRepository<tblUserExt> _userRepository;

    public UserService(IGenericRepository<tblUserExt> userRepository)
    {
        _userRepository = userRepository;
    }

    public async Task<tblUserExt?> GetUserWithBranch(Guid userId)
    {
        return await _userRepository.FirstOrDefaultAsync(
            u => u.UserID == userId,
            "UserBranchMapping"
        );
    }
}

using Microsoft.EntityFrameworkCore;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    // DbSets for your tables
    public virtual DbSet<tblUserExt> tblUserExts { get; set; } = null!;
    public virtual DbSet<UserBranchMapping> UserBranchMappings { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Fluent API for one-to-one relationship on UserID
        modelBuilder.Entity<tblUserExt>()
            .HasOne(u => u.UserBranchMapping)
            .WithOne(b => b.tblUserExt)
            .HasForeignKey<UserBranchMapping>(b => b.UserID)
            .HasPrincipalKey<tblUserExt>(u => u.UserID)
            .OnDelete(DeleteBehavior.Restrict); // Or whatever suits your data logic

        // Optional: Unique constraint for UserID if not already in DB
        modelBuilder.Entity<UserBranchMapping>()
            .HasIndex(b => b.UserID)
            .IsUnique();
    }
}

builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));





using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

public partial class tblUserExt
{
    [Key]
    public long UserExtID { get; set; }

    public Guid? RoleID { get; set; }

    public Guid UserID { get; set; }

    public string? RoleName { get; set; }

    public string? UserName { get; set; }

    [Required]
    public string IMDCode { get; set; } = string.Empty;

    public bool? IsActive { get; set; }

    public bool? IsBlocked { get; set; }

    public string? FirstName { get; set; }

    public string? LastName { get; set; }

    public bool? IsSubID { get; set; }

    public bool? HasParent { get; set; }

    public bool? HasCumulative { get; set; }

    public bool CanCreateUser { get; set; }

    public decimal? VerticalId { get; set; }

    public bool? CancellationRights { get; set; }

    public bool? ForgotPasswordStatus { get; set; }

    public decimal? GroupId { get; set; }

    public bool? IsAgentBlocked { get; set; }

    public bool? isTPPartner { get; set; }

    public bool? isAdvancePaymentAllowed { get; set; }

    public bool? IsDocumentAccessed { get; set; }

    public bool? IsParentinAVO { get; set; }

    public string? ParentIMDCodeinAVO { get; set; }

    public string? AppUserType { get; set; }

    // Navigation property for one-to-one relationship
    public virtual UserBranchMapping? UserBranchMapping { get; set; }
}



using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

public partial class UserBranchMapping
{
    [Key]
    public decimal ID { get; set; }

    public Guid UserID { get; set; }

    public decimal BranchID { get; set; }

    // Optional navigation to MASBranch if needed
    // public virtual MASBranch MASBranch { get; set; }

    // Navigation property for one-to-one relationship
    public virtual tblUserExt? tblUserExt { get; set; }
}




